from typing import List

from thefuzz import process


def get_highlight(text: str, summaries: List[str]):
    splitted = text.split(".")
    for summary_text in summaries:
        match = process.extractOne(summary_text, splitted)
        if match:
            text = text.replace(match[0], f"<mark>{match[0]}</mark>")
    return text


if __name__ == "__main__":

    INNER_HTML = """'\n\n    <nav class="nav">\n  <div class="nav-container">\n    <a href="/program-synthesis-minimal/">\n      <h2 class="nav-title">a minimalist guide to program synthesis</h2>\n    </a>\n    <ul>\n      <li><a href="/program-synthesis-minimal/">Posts</a></li>\n      \x3C!-- <li><a href="/program-synthesis-minimal/tags">Tags</a></li> -->\n      <li><a href="/program-synthesis-minimal/about">About</a></li>\n    </ul>\n  </div>\n</nav>\n\n\n\n    <main>\n      <div class="post">\n  \x3C!-- <div class="post-info">\n    <span>written by</span>\n    \n        evanthebouncy\n    \n\n    \n      <br>\n      <span>on&nbsp;</span><time datetime="2022-08-11 00:00:00 +0000">August 11, 2022</time>\n    \n  </div> -->\n\n  <h1 class="post-title">what you will find here</h1>\n  <div class="post-line"></div>\n\n  <h1 id="so-you-want-to-know-about-program-synthesis">so, you want to know about program synthesis?</h1>\n\n<p>Recently (as of 2022), the topic of “building AI to write code” has become fashionable in both industry and academia, with <a href="https://github.com/features/copilot">copilot</a> making its way to production (if you have not used it, stop reading and play with it first). However, program synthesis is more than generating few lines of code from comments. Programs are broadly useful in modeling both computation and communication, and whenever programs exist, program synthesis is sure to follow.</p>\n\n
    <p><ins>This blog series serves as a entry-point to the <strong>practical</strong>, <strong>modern</strong> aspects of program synthesis.</ins> I intend to keep the write-ups concise, at a cost of accuracy. The examples will be pedagogical, introducing you to a concept and coding it up using off-the-shelf technologies, at a cost of fidelity. The goal is 入门 (to get your foot through the door), so you can read and replicate academic literatures, and have the confidence to apply program synthesis to your own works.</p>\n\n<p>This blog is intented for undergraduate/graduate level researchers with knowledge of machine-learning, who want to “get into” program synthesis. Some level of mathematical maturity will be assumed, but not essential as the algorithms and applications are self-contained.</p>\n\n<p>Let us begin.</p>\n\n<h2 id="programming">programming</h2>\n<p>Before computers, when a person has a task to do, they manually does stuff. This is tiring.\n<img src="/program-synthesis-minimal/assets/what-is-this/doing.png" alt="Image with caption" title="doing"></p>\n\n<p>Programming is the act of a person asking the computer to do something. Hacking the linux kernel is programming. Creating an email filter is programming. Me setting up this blog is programming. One must always think of programming with these three: a programmer, a program, and an interpreter. A <strong>programmer</strong> turns a task into a program. A <strong>program</strong> is the thing that programmer gives, which the interpreter understands. An <strong>interpreter</strong> takes in the program and does stuff.</p>
    \n\n\x3C!-- \nProgramming consists of a **programmer**, who writes a **program**, which is executed on an **interpreter**. One must think about programming with all three in mind! -->\n<p><img src="/program-synthesis-minimal/assets/what-is-this/programming1.png" alt="Image with caption" title="programming"></p>\n\n<p>We program because interpreters (computers) can help us with difficult tasks. A human cannot multiplex different apps at 4GHz. A human cannot sort through 1000s of emails manually. I cannot deliver the blog to all of you in person.</p>\n\n<h2 id="program-synthesis">program synthesis</h2>\n<p>Program synthesis is a system that makes programming easier. gcc frees you from having to write assembly. Using “filter emails like this” makes creating a filter easier. Jekyll generating the website makes creating this blog easier. With program synthesis, the programmer can now program using “program++”, which is easier to use than “program”. The <strong>synthesizer</strong> is a middle-man programmer, which turns program++ into a program.</p>\n\n<p><img src="/program-synthesis-minimal/assets/what-is-this/prog_plus.png" alt="Image with caption" title="synthesis"></p>\n\n<p>Together, the synthesizer and the interpreter becomes a better interpreter, the “interpreter++”, which takes in program++ (commonly called a <strong>spec</strong> for specification) and does stuff. Note how this process can be recursive, where we build layers upon layers of synthesizers/interpreters, making it easier and easier for a human to program. Thus, program synthesis is simply “easier programming” – one step of this recursive process – and must be stated in relationship with the original “harder programming” context. Let’s see some examples.</p>
    \n\n<h2 id="a-brief-history-of-program-synthesis">a brief history of program synthesis</h2>\n<p>The first synthesizers were compilers, which automatically generated code (assembly) from high-level specifications (FORTRAN). In <strong>deductive synthesis</strong><sup id="fnref:deductive" role="doc-noteref"><a href="#fn:deductive" class="footnote" rel="footnote">1</a></sup>, one transforms a specification (the array should become sorted) using mathematical rules, resulting in a provably correct program (the merge-sort algorithm).</p>\n\n<p>Most modern synthesis are <strong>inductive synthesis</strong> – where the algorithm performs a <em>search</em> to find a solution that meets the specification. In neuro-symbolic<sup id="fnref:neurosym" role="doc-noteref"><a href="#fn:neurosym" class="footnote" rel="footnote">2</a></sup> program synthesis, the search is performed with a neural-network, which proposes plausible (symbolic) programs. Recent (2020+) advances <sup id="fnref:alphacode" role="doc-noteref"><a href="#fn:alphacode" class="footnote" rel="footnote">3</a></sup>,<sup id="fnref:codex" role="doc-noteref"><a href="#fn:codex" class="footnote" rel="footnote">4</a></sup> frequently leverages natural language (such as code comments) as additional context to guide the search (to generate python code). The subject of transforming natural language to executable programs (think siri or alexa) traditionally falls under <strong>semantic-parsing</strong><sup id="fnref:sem-parse" role="doc-noteref"><a href="#fn:sem-parse" class="footnote" rel="footnote">5</a></sup>,<sup id="fnref:sem-tutorial" role="doc-noteref"><a href="#fn:sem-tutorial" class="footnote" rel="footnote">6</a></sup>.</p>\n\n<p>Lastly, as programs are flexible in representing symbolic knowledge, they have been used to model cognition <sup id="fnref:joshrule" role="doc-noteref"><a href="#fn:joshrule" class="footnote" rel="footnote">7</a></sup>,<sup id="fnref:probmods" role="doc-noteref"><a href="#fn:probmods" class="footnote" rel="footnote">8</a></sup>, where learning can be thought of as a form of “program induction”.</p>
    \n\n<p>As we cannot afford the space to go into it further, kindly refer to <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">9</a></sup>,<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">10</a></sup> for more history.</p>\n\n<h2 id="where-do-we-stand-now">where do we stand now?</h2>\n<p>Program synthesis had a fairly big 门槛 (entry barrier). You needed expertise in programming language design, compilers, constraint-solving, semantic-parsing, and designing specific neural-network architectures tailored toward code generation. However, with recent advances of foundational models, I believe (could be wrong) most of these expertise are no longer required to get started. With this blog, I hope you can replicate the workflow of a typical program synthesis practitioner with a lighter toolbox.</p>\n\n<h2 id="what-is-the-end-game">what is the end game?</h2>\n<p>We can take a <a href="https://youtu.be/RB78vRUO6X8">Joshian</a> point of view (gesturing wildly at humans), and let the goal of program synthesis be building a system that can subsitute for a human developer (programmer) – who turns fully naturalistic human-human interactions into working programs. The art of program synthesis is making program++/specification as humane as possible, while keeping the mapping between program++ and program tractable.</p>\n\n<p><img src="/program-synthesis-minimal/assets/what-is-this/synthesis-ultimate1.png" alt="Image with caption" title="human-program"></p>\n
    \n<p>Of course, we don’t have to be limited by human programming capabilities. We aim to build a synthesizer that can to go even further beyond!! AAaaaaaAaaA<a href="https://youtu.be/3FM2kbvYljw?t=18">AAaaaAA</a>AAaaAaahhHHhHHhH (okay I’ll stop).</p>\n\n<h2 id="exercise">exercise</h2>\n<p>In program synthesis, the word <em>intent</em> always shows up, and yet is rarely formally defined. Pick several different programming scenarios and attempt to formalize the notion of programmer’s intent in your own words. How easy would it be to convey this formalized intent to a fellow human? How easy would it be to convey it to a machine?</p>\n\n<p>– evan  2022-08-11</p>\n\n<h2 id="up-next">up next</h2>\n<p>The next post covers how to set-up a typical synthesis problem. <a href="/program-synthesis-minimal/typical-synthesis-problem/">let’s go for it</a></p>\n\n<h3 id="notes">notes</h3>\n\n<div class="footnotes" role="doc-endnotes">\n  <ol>\n    <li id="fn:deductive" role="doc-endnote">\n      <p><a href="https://people.csail.mit.edu/asolar/SynthesisCourse/Lecture17.htm">Armando’s lecture notes on deductive synthesis</a>&nbsp;<a href="#fnref:deductive" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:neurosym" role="doc-endnote">\n      <p><a href="https://www.cs.utexas.edu/~swarat/pubs/PGL-049-Plain.pdf">A 2021 survey on neuro-symbolic program synthesis</a>&nbsp;<a href="#fnref:neurosym" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:alphacode" role="doc-endnote">\n      <p><a href="https://www.deepmind.com/blog/competitive-programming-with-alphacode">Competitive programming with AlphaCode</a>&nbsp;<a href="#fnref:alphacode" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:codex" role="doc-endnote">\n      <p><a href="https://arxiv.org/abs/2107.03374">Evaluating Large Language Models Trained on Code</a>&nbsp;<a href="#fnref:codex" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:sem-parse" role="doc-endnote">\n      
    <p><a href="https://web.stanford.edu/~cgpotts/manuscripts/liang-potts-semantics.pdf">Bringing machine learning and compositional semantics together by Percy Liang</a>&nbsp;<a href="#fnref:sem-parse" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:sem-tutorial" role="doc-endnote">\n      <p><a href="https://github.com/allenai/acl2018-semantic-parsing-tutorial">ACL 2018 tutorial on neural semantic parsing</a>&nbsp;<a href="#fnref:sem-tutorial" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:joshrule" role="doc-endnote">\n      <p><a href="http://colala.berkeley.edu/papers/rule2020child.pdf">The Child as Hacker</a>&nbsp;<a href="#fnref:joshrule" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:probmods" role="doc-endnote">\n      <p><a href="http://probmods.org/">Probabilistic Models of Cognition</a>&nbsp;<a href="#fnref:probmods" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:1" role="doc-endnote">\n      
    <p><a href="https://people.csail.mit.edu/asolar/SynthesisCourse/Lecture1.htm">Armando’s lecture notes on definition and history of program synthesis</a>&nbsp;<a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n    <li id="fn:2" role="doc-endnote">\n      <p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/10/program_synthesis_now.pdf">A 2017 survey on program synthesis by microsoft folks</a>&nbsp;<a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>\n    </li>\n  </ol>\n</div>\n\n</div>\n\n\n\n<div class="pagination">\n  \n  \n    <a href="/program-synthesis-minimal/typical-synthesis-problem/" class="right arrow">→</a>\n  \n\n  <a href="#" class="top">Top</a>\n</div>\n    </main>\n\n    <footer>\n  <span>\n    © <time datetime="2022-10-14 17:09:50 +0000">2022</time> evanthebouncy. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.\n  </span>\n</footer>\n\n  \n\n<div id="__memex-ext-installed-detection-element" style="display: none !important;"></div>'"""

    SUMMARY = [
        "We can take a Joshian point of view (gesturing wildly at humans), and let the goal of program synthesis be building a system that can subsitute for a human developer (programmer) – who turns fully naturalistic human-human interactions into working programs.",
        "Lastly, as programs are flexible in representing symbolic knowledge, they have been used to model cognition 7,8, where learning can be thought of as a form of “program induction”.",
        "Recently (as of 2022), the topic of “building AI to write code” has become fashionable in both industry and academia, with copilot making its way to production (if you have not used it, stop reading and play with it first).",
        "With program synthesis, the programmer can now program using “program++”, which is easier to use than “program”.",
        "exercise In program synthesis, the word intent always shows up, and yet is rarely formally defined.",
        "Programs are broadly useful in modeling both computation and communication, and whenever programs exist, program synthesis is sure to follow.",
        "The goal is 入门 (to get your foot through the door), so you can read and replicate academic literatures, and have the confidence to apply program synthesis to your own works.",
        "One must always think of programming with these three: a programmer, a program, and an interpreter.",
        "Recent (2020+) advances 3,4 frequently leverages natural language (such as code comments) as additional context to guide the search (to generate python code).",
        "Programming is the act of a person asking the computer to do something.",
        "However, with recent advances of foundational models, I believe (could be wrong) most of these expertise are no longer required to get started.",
        "Thus, program synthesis is simply “easier programming” – one step of this recursive process – and must be stated in relationship with the original “harder programming” context.",
    ]

    print(get_highlight(INNER_HTML, SUMMARY))
